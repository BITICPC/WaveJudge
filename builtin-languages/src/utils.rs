//! This module provides some utility functions to the crate.
//!

use std::path::{Path, PathBuf};

use serde::de::DeserializeOwned;

use crate::InitLanguageError;


/// Create a path to the compiled executable file generated by the given source file.
///
/// This function concatenates `file_stem` of `source_file` to the tail of `output_dir`; if
/// `output_dir` is `None`, then the file stem is concatenated to the current working directory.
pub fn make_output_file_path<T1, T2>(source_file: T1, output_dir: Option<T2>) -> PathBuf
    where T1: AsRef<Path>, T2: AsRef<Path> {
    let mut path = output_dir.map(|x| PathBuf::from(x.as_ref()))
        .unwrap_or_else(|| PathBuf::from("."));
    path.push(source_file.as_ref().file_stem().expect("no file_stem found on source_file."));

    path
}

/// Provide a trait for all configuration structures used in this crate.
pub trait Config : DeserializeOwned {
    /// Load this configuration from the specified file.
    fn from_file<P>(path: &P) -> Result<Self, InitLanguageError>
        where P: ?Sized + AsRef<Path> {
        let content = std::fs::read_to_string(path)
            .map_err(|e| InitLanguageError::new(
                format!("failed to read content of language provider config file: {}", e)))
            ?;
        let config = serde_yaml::from_str::<Self>(&content)
            .map_err(|e| InitLanguageError::new(
                format!("failed to load language provider config: {}", e)))
            ?;
        Ok(config)
    }
}


#[cfg(test)]
mod tests {
    use std::path::Path;

    use super::make_output_file_path;

    #[test]
    fn test_make_output_file_path() {
        assert_eq!("./hello", make_output_file_path("abc/hello.cpp", Option::<&Path>::None)
            .to_str().unwrap());
        assert_eq!("abc/hello", make_output_file_path("efg/hello.cpp", Some("abc"))
            .to_str().unwrap());
    }
}
